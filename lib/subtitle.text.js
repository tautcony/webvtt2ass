var he = require('he');
var TimeSpan  = require('./timespan');

var default_font = 'Arial';

function assHead(font) {
    if (font === undefined) {
        font = default_font;
    }
    'use strict';
    var ret = '[Script Info]\n; Script generated by webvtt2ass\nScriptType: v4.00+\nWrapStyle: 0\nScaledBorderAndShadow: yes\nYCbCr Matrix: NonePlayResX: 1920\nPlayResY: 1080\n\n' +
    '[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n' +
    'Style: Default,' + font + ',50,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0.5,2,10,10,10,1\n' +
    'Style: Ruby,'    + font + ',50,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0.5,2,10,10,10,1\n\n' +
    '[Events]\nFormat: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text\n' +
    'Comment:  0,00:00:00.00,00:00:00.00,Ruby,,0,0,0,template furi,{\\pos(!line.left+syl.center!,!line.middle-line.height!)\\an5}\n' +
    'Comment:  0,00:00:00.00,00:00:00.00,Ruby,,0,0,0,template syl,{\\pos(!line.left+syl.center!,!line.middle!)\\an5}\n';
    return ret;
}

//src: <ruby>明日<rt>あした</tr></ruby>また<ruby>会<rt>あう</rt></ruby><ruby>時<rt>とき</rt></ruby>
//tgt: {\k}明日|あした{\k}また{\k}会|あう{\k}時|とき
//ref: http://docs.aegisub.org/manual/Furigana_karaoke

function parseTreeRuby(tree) {
    var ret = '{\\k}';
    tree.children.forEach(item => {
        if (item.type === 'text') {
            ret += item.value;
        } else if (item.type === 'object') {
            if (item.name === 'rt') {
                ret += '|' + parseTreeInner(item, true).text;
                ret += '{\\k}';
            }
        }
    });
    return ret;
}

function parseTreeInner(tree, noTag) {
    'use strict';
    var nodes = tree.children;
    var ret = { text: '' };
    if (tree.name === 'ruby') {
        ret.text += parseTreeRuby(tree);
        ret.style = 'Ruby';
    } else {
        if (tree.name === 'v') {
            ret.voice = tree.value;
        }
        nodes.forEach(item => {
            if (item.type === 'object') {
                var temp = parseTreeInner(item);
                ret.text += temp.text;
                ret.style = temp.style;
                if (ret.voice === undefined) {
                    ret.voice = temp.voice;
                }
            } else {
                ret.text += item.value;
            }
        });
        if (tree.name !== undefined && noTag === undefined) {
            if (tree.name !== 'v') {
                ret.text = "{\\" + tree.name + "1}" + ret.text + "{\\" + tree.name + "0}";
            }
        }
    }
    return ret;
}

function parsePosition(line) {
    var an = 2;
    if (line.alignment === "end") {
        an = 3;
    } else if (line.alignment === "start") {
        an = 1;
    }
    const isHorizontal = line.horizontal === "horizontal";
    return line;
}

function parseSegment(line) {
    'use strict';
    var ret = parseTreeInner(line.tree);
    if (ret.voice === undefined) {
        ret.voice = '';
    }
    if (ret.style === undefined) {
        ret.style = 'Default';
    }
    ret.text = he.decode(ret.text).replace(/\n/g, '\\N');
    ret.begin = new TimeSpan(line.startTime).assFormat();
    ret.end   = new TimeSpan(line.endTime).assFormat();
    return ret;
}

module.exports = { parseSegment: parseSegment, assHead: assHead };
